<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Duochrome Trainer — Over-Rx = Target − Participant (J0/J45, ΔM) + Cyl Toggle + Reset + Target Limits</title>
<style>
  body { font-family: system-ui, sans-serif; background:#fff; text-align:center; margin:20px; }
  #currentRx { font-weight:500; font-size:15px; margin-bottom:10px; }

  .card{
    background:#fff; border-radius:10px; padding:20px 80px;
    box-shadow:0 0 10px rgba(0,0,0,0.3); display:inline-block;
    border:1px solid darkgrey;
    margin:8px 0 14px;
  }
  .row input[type=number]{ width:70px; text-align:center; }
  .row b{ display:inline-block; margin-bottom:6px; }
  button{ margin:5px; padding:5px 10px; cursor:pointer; }

  /* Duochrome stage */
  .duochrome{
    display:flex; justify-content:center; align-items:center;
    width:300px; height:300px; margin:20px auto; position:relative;
    overflow:hidden;
  }
  .duo-side{
    position:relative; width:150px; height:300px;
    display:flex; align-items:center; justify-content:center;
    overflow: clip; contain: paint; isolation: isolate;
  }
  @supports not (overflow: clip) { .duo-side { overflow: hidden; } }

  /* Trim 10px edges */
  #redSide  { clip-path: inset(0 0 0 10px); }
  #blueSide { clip-path: inset(0 10px 0 0); }

  .duo-side img.base{
    width:150px; height:300px; object-fit:cover; display:block;
    transition:none; will-change: filter;
  }
  .duo-side img.overlay{
    position:absolute; left:0; top:0;
    width:150px; height:300px; object-fit:cover; pointer-events:none;
    transition:none; will-change: transform, filter, opacity;
    backface-visibility:hidden; transform: translate3d(0,0,0);
  }

  /* Fan chart */
  .outer-circle{
    width:250px; height:250px; border-radius:50%; border:none;
    overflow:hidden; display:flex; align-items:center; justify-content:center;
    margin:40px auto; transform-origin:center;
  }
  .circular-img img{
    width:300px; height:auto; object-fit:cover; object-position:center;
    transform-origin:center;
  }

  /* Side-by-side layout for duochrome + fan chart */
  #stage {
    display: flex;
    gap: 50px;
    align-items: center;
    justify-content: center;
  }
  .duochrome, .outer-circle { margin: 12px 0; }

  .rx-input {
    width: 120px; font-size: 12px; text-align: center;
    padding: 6px; border-radius: 6px; border: 1px solid #ccc; margin-bottom: 5px;
  }
  .btn-plus, .btn-minus {
    font-size: 14px; border: 1px solid black; padding: 6px 10px;
    border-radius: 6px; cursor: pointer; color: #fff; transition: opacity 0.2s; margin: 2px;
  }
  .btn-plus { background-color: #2e8b57; }  /* Kiara green */
  .btn-minus { background-color: #d9534f; } /* soft red */
  .btn-plus:hover, .btn-minus:hover { opacity: 0.8; }

  .btn-group button {
    font-size: 12px; padding: 5px 5px; margin: 5px;
    border: 1px solid black; border-radius: 10px; cursor: pointer;
    background-color: lightgrey; color: black; min-width: 160px;
  }
  .btn-group button:hover { background-color: darkgrey; }
  .btn-group button:active { transform: scale(0.98); }
</style>
</head>
<body>



<div id="currentRx">FANCHART & DUOCHROME TRAINER </div>

<div id="targetPanel" style="
  display:none;
  font-size:12px;               /* bigger text */
  line-height:1.6;
  padding:16px 20px;            /* more padding */
  border:1px solid #bbb; 
  border-radius:12px;
  background:#fff;
  max-width:520px;              /* roomy but tidy */
  margin:12px auto;
">
  <b style="font-size:14px;">Target Rx (hidden)</b><br>
  SPH 
  <input type="number" id="tSph" step="0.25" value="-1.00" style="width:80px; font-size:12px; padding:8px; margin:6px 10px 6px 6px;">
  CYL 
  <input type="number" id="tCyl" step="0.25" value="-1.00" style="width:80px; font-size:12px; padding:8px; margin:6px 10px;">
  AXIS 
  <input type="number" id="tAxis" step="5" value="180" style="width:80px; font-size:12px; padding:8px; margin:6px 0 6px 10px;">
  <div style="margin-top:10px; font-size:12px; color:#666;">
    Limits: SPH +4.00…−7.00 · CYL 0 to −4.00 (minus) · AXIS 1–180
  </div>
</div>



<div>
<!-- Target Rx (hidden by default) -->
<div id="targetPanel" style="display:none;">
    <b>Target Rx (hidden)</b><br>
    SPH <input type="number" id="tSph" step="0.25" value="-1.00">
    CYL <input type="number" id="tCyl" step="0.25" value="-1.00">
    AXIS <input type="number" id="tAxis" step="5" value="180">
    <div style="margin-top:6px; font-size:12px; color:#666;">
      Limits: SPH +4.00…−7.00 · CYL 0 to −4.00 (minus) · AXIS 1–180
  </div>
</div>

<!-- Participant Rx -->
<div id="controls" class="card" style="font-size:15px;">
  You challenge is to find the RX that makes everything clear again!<br><br>


  <div style="display:flex; justify-content:center; gap:50px; flex-wrap:wrap; align-items:flex-start;">
    <!-- SPH -->
    <div style="text-align:center;">
      <label><b>SPH</b></label><br>
      <input type="number" id="sph" step="0.25" value="0.00" class="rx-input"><br>
      <div>
        <button onclick="adj('sph',-0.25)" class="btn-minus">−0.25</button>
        <button onclick="adj('sph',0.25)" class="btn-plus">+0.25</button><br>
        <button onclick="adj('sph',-1.00)" class="btn-minus">−1.00</button>
        <button onclick="adj('sph',1.00)" class="btn-plus">+1.00</button>
      </div>
    </div>

    <!-- CYL -->
    <div style="text-align:center;">
      <label><b>CYL</b></label><br>
      <input type="number" id="cyl" step="0.25" value="0.00" class="rx-input"><br>
      <div>
        <button onclick="adj('cyl',-0.25)" class="btn-minus">−0.25</button>
        <button onclick="adj('cyl',0.25)" class="btn-plus">+0.25</button><br>
        <button onclick="adj('cyl',-1.00)" class="btn-minus">−1.00</button>
        <button onclick="adj('cyl',1.00)" class="btn-plus">+1.00</button>
      </div>
    </div>

    <!-- AXIS -->
    <div style="text-align:center;">
      <label><b>AXIS</b></label><br>
      <input type="number" id="axis" step="5" value="180" class="rx-input"><br>
      <div>
        <button onclick="adj('axis',-5)" class="btn-minus">−5</button>
        <button onclick="adj('axis',5)" class="btn-plus">+5</button>
      </div>
    </div>
  </div>

  <div style="height:15px"></div>

  <div class="row btn-group">
    <button id="resetBtn">Reset Participant</button>
    <button id="sizeBtn">Letter Size: Medium</button>
    <button id="formToggleBtn">To +cyl</button>
  </div>

  <div style="height:5px"></div>
  <div class="row btn-group">
    <button id="randBtn">New Target</button>
    <button id="targetToggleBtn">Show Target</button>
  </div>

  <div style="height:10px"></div>

  <!-- Smart Coach Box -->
  <div id="coachBox" style="
    margin-top:20px; background:#fffdf0; border:1px solid #ccc;
    border-radius:10px; padding:12px 20px; display:inline-block;
    text-align:left; font-size:12px; line-height:1.5; width:620px;">
    <div><b>DUOCHROME ▶</b> Adjust SPH until red side is slightly clearer.</div>
    <div><b>DIRECTION ▶</b> Align with the darkest fan line.</div>
    <div><b>LINES DARKNESS ▶</b> Increase +CYL until all lines appear equal.</div>
  </div>
</div>



</div>

<div style="height:10px"></div>

<div id="stage">
  <!-- Fan Chart (LEFT) -->
  <div id="stack" style="position:relative; width:400px; margin:0 0 20px 0;">
    <img class="bg"
         src="https://raw.githubusercontent.com/kiaraoptometrypx/Trainer/main/FC_DIRECTIONS.png"
         alt="Fan Chart Directions"
         style="width:100%; display:block;" />
    <div class="overlay" style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none;">
      <div class="overlay-stage">
        <div class="outer-circle" id="outerCircle" style="width:100%; aspect-ratio:1/1; border-radius:9999px; overflow:hidden;">
          <div class="circular-img" style="width:100%; height:100%;">
            <img id="fanChart"
                 src="https://raw.githubusercontent.com/kiaraoptometrypx/Trainer/main/C025.png"
                 alt="Fan Chart"
                 style="width:100%; height:100%; object-fit:cover;" />
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Duochrome (RIGHT) -->
  <div class="duochrome">
    <div class="duo-side" id="redSide">
      <img class="base" id="redImg" src="https://raw.githubusercontent.com/kiaraoptometrypx/Trainer/main/RED_2.png" alt="Red">
      <img class="overlay" id="redOv" alt="Red overlay">
    </div>
    <div class="duo-side" id="blueSide">
      <img class="base" id="blueImg" src="https://raw.githubusercontent.com/kiaraoptometrypx/Trainer/main/BLUE_2.png" alt="Blue">
      <img class="overlay" id="blueOv" alt="Blue overlay">
    </div>
  </div>
</div>



<script>
/* =========================
   Quick adjust buttons
========================= */
function adj(type, step){
  const el = document.getElementById(type);
  let v = parseFloat(el.value)||0;
  v += step;
  if(type==='axis'){
    if(v < 1) v = 180;
    if(v > 180) v = 1;
    el.value = Math.round(v);
  } else {
    el.value = v.toFixed(2);
  }
  el.dispatchEvent(new Event('input'));
}
</script>

<script>
/* ===== Tunables ===== */
const PX_PER_D = 2;
const K_BLUR_PER_D = 2.0;
const EXTRA_ASTIG_BLUR_PER_D = 0.40;
const OVERLAY_ALPHA = 0.60;
const AXIS_STEP = 5;
/* Target limits */
const T_SPH_MIN = -7.00, T_SPH_MAX = +4.00;
const T_CYL_MIN = -4.00, T_CYL_MAX = 0.00;
/* ===================== */

const redImg = document.getElementById('redImg');
const blueImg = document.getElementById('blueImg');
const redOv = document.getElementById('redOv');
const blueOv = document.getElementById('blueOv');
const fanImg = document.getElementById('fanChart');
const outer = document.getElementById('outerCircle');
const FC_BLUR_GAIN = 0.50;

const sphInput = document.getElementById('sph');
const cylInput = document.getElementById('cyl');
const axisInput = document.getElementById('axis');

const randBtn = document.getElementById('randBtn');
const sizeBtn = document.getElementById('sizeBtn');
const targetToggleBtn = document.getElementById('targetToggleBtn');
const formToggleBtn = document.getElementById('formToggleBtn');
const resetBtn = document.getElementById('resetBtn');

const targetPanel = document.getElementById('targetPanel');
const tSph = document.getElementById('tSph');
const tCyl = document.getElementById('tCyl');
const tAxis = document.getElementById('tAxis');

let letterSize = 2;
let TARGET = { S: -1.00, C: -1.00, A: 180 };
let TRUE = { sph: 0, cyl: 0, axis: 180, se: 0 };

/* Preload Assets */
const SIZES = [1,2,3];
const cache = {};
(function preloadAll(){
  SIZES.forEach(sz=>{
    ["RED","BLUE"].forEach(col=>{
      const url = `https://raw.githubusercontent.com/kiaraoptometrypx/Trainer/main/${col}_${sz}.png`;
      const im = new Image(); im.decoding = "async"; im.src = url;
      cache[`${col}_${sz}`] = im;
    });
  });
})();

async function applyLetterImages(){
  const rKey = `RED_${letterSize}`, bKey = `BLUE_${letterSize}`;
  await Promise.all([cache[rKey].decode?.().catch(()=>{}), cache[bKey].decode?.().catch(()=>{})]);
  redImg.src = cache[rKey].src;  redOv.src = cache[rKey].src;
  blueImg.src = cache[bKey].src; blueOv.src = cache[bKey].src;
}

/* Helpers */
const quant05 = v => Math.round(v*2)/2;
function wrapAxis(val){
  const n = parseFloat(val);
  if (!Number.isFinite(n)) return 0;
  const raw = String(val).trim();
  let v = ((Math.round(n) % 180) + 180) % 180;
  return raw === "180" ? 180 : (v === 0 ? 1 : v);
}
function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

/* Normalize to minus cyl */
function normalizeMinus(S, C, A){
  if (C > 0){
    S = S + C; C = -C; A = (wrapAxis(A + 90)) || 180;
  } else A = wrapAxis(A);
  return { S, C, A };
}

function clampTarget(obj){
  let S = clamp((+obj.S || 0), T_SPH_MIN, T_SPH_MAX);
  let C = (+obj.C || 0);
  if (C > 0) C = -C;
  C = clamp(C, T_CYL_MIN, T_CYL_MAX);
  let A = wrapAxis(+obj.A || 180);
  return { S, C, A };
}

/* Power-vector math */
function toVec(S, C, Adeg){
  const rad2 = (2*Adeg) * Math.PI/180;
  const M  = S + C/2;
  const J0 = -(C/2) * Math.cos(rad2);
  const J45= -(C/2) * Math.sin(rad2);
  return {M,J0,J45};
}
function fromVec(M, J0, J45){
  const C = -2 * Math.hypot(J0, J45);
  let A = 0.5 * (Math.atan2(J45, J0) * 180/Math.PI);
  A = ((A % 180) + 180) % 180 || 180;
  const S = M - C/2;
  return {S, C, A};
}

function getParticipantMinus(){
  const S = parseFloat(sphInput.value)||0;
  const C = parseFloat(cylInput.value)||0;
  const A = wrapAxis(axisInput.value||0);
  return normalizeMinus(S, C, A);
}

function recomputeOver(){
  const Pm = getParticipantMinus();
  const Tm = normalizeMinus(...Object.values(clampTarget(TARGET)));

  const t = toVec(Tm.S, Tm.C, Tm.A);
  const p = toVec(Pm.S, Pm.C, Pm.A);
  const d = { M: t.M - p.M, J0: t.J0 - p.J0, J45: t.J45 - p.J45 };
  const o = fromVec(d.M, d.J0, d.J45);

  TRUE.sph  = o.S;
  TRUE.cyl  = o.C;
  TRUE.axis = o.A;
  TRUE.se   = d.M;

  updateViews();
}

function updateViews(){
  const cyl  = TRUE.cyl;
  const axis = TRUE.axis;
  const deltaSE = TRUE.se;

  const s = Math.abs(deltaSE);
  const primary   = s * K_BLUR_PER_D;
  const secondary = (s >= 0.75) ? ((s - 0.5) * K_BLUR_PER_D) : 0;
  const fcBlur = quant05(primary * FC_BLUR_GAIN);

  let blurRed=0, blurBlue=0;
  if (deltaSE > 0){ blurRed = primary; blurBlue = secondary; }
  else if (deltaSE < 0){ blurBlue = primary; blurRed = secondary; }

  redImg.style.filter  = `blur(${quant05(blurRed)}px)`;
  blueImg.style.filter = `blur(${quant05(blurBlue)}px)`;

  const mag = Math.abs(cyl) * PX_PER_D;
  let ang = (axis % 180) * 2; ang -= 90;
  const rad = ang * Math.PI / 180;
  const shiftX = Math.round(Math.cos(rad) * mag);
  const shiftY = Math.round(Math.sin(rad) * mag);

  redOv.style.transform  = `translate(${shiftX}px, ${shiftY}px)`;
  blueOv.style.transform = `translate(${shiftX}px, ${shiftY}px)`;

  const extra = Math.abs(cyl) * EXTRA_ASTIG_BLUR_PER_D;
  redOv.style.filter  = `blur(${quant05(blurRed  + extra)}px)`;
  blueOv.style.filter = `blur(${quant05(blurBlue + extra)}px)`;
  redOv.style.opacity = blueOv.style.opacity = OVERLAY_ALPHA;

  const absC = Math.abs(cyl);
  let imgName = "C025.png";
  if(absC<=0.25) imgName="C025.png";
  else if(absC<=0.50) imgName="C050.png";
  else if(absC<=0.75) imgName="C075.png";
  else if(absC<=1.00) imgName="C100.png";
  else imgName="C150.png";
  fanImg.src = `https://raw.githubusercontent.com/kiaraoptometrypx/Trainer/main/${imgName}`;
  fanImg.style.filter = `blur(${fcBlur}px)`;

  const axisFC = (axis + 90) % 180;
  const fcOffset = (deltaSE > 0) ? 90 : 0;
  outer.style.transform = `scaleX(-1) rotate(${-(axisFC + fcOffset)}deg)`;

  updateCoach();
}

/* Input Wiring */
[sphInput, cylInput].forEach(el => el.addEventListener('input', ()=>{recomputeOver();}));
axisInput.addEventListener('input', ()=>{
  axisInput.value = wrapAxis(axisInput.value||0);
  recomputeOver(); updateCoach();
});
axisInput.addEventListener("keydown", (e) => {
  if (e.key === "ArrowUp") { e.preventDefault(); axisInput.value = wrapAxis((parseFloat(axisInput.value) || 0) + AXIS_STEP); }
  if (e.key === "ArrowDown") { e.preventDefault(); axisInput.value = wrapAxis((parseFloat(axisInput.value) || 0) - AXIS_STEP); }
  recomputeOver(); updateCoach();
});

/* Size switch */
sizeBtn.addEventListener('click', async ()=>{
  letterSize = letterSize % 3 + 1;
  sizeBtn.textContent = `Letter Size: ${letterSize===1?'Small':letterSize===2?'Medium':'Large'}`;
  await applyLetterImages();
  updateViews();
});

/* Show / Hide Target Panel */
targetToggleBtn.addEventListener('click', () => {
  const open = targetPanel.style.display !== "none";
  targetPanel.style.display = open ? "none" : "block";
  targetToggleBtn.textContent = open ? "Show Target" : "Hide Target";
});

/* Edit Target -> clamp + recompute */
[tSph, tCyl].forEach(el=>{
  el.addEventListener('input', ()=>{
    TARGET.S = parseFloat(tSph.value)||0;
    TARGET.C = parseFloat(tCyl.value)||0;
    TARGET = clampTarget(TARGET);
    tSph.value = TARGET.S.toFixed(2);
    tCyl.value = TARGET.C.toFixed(2);
    recomputeOver(); updateCoach();
  });
});
tAxis.addEventListener('input', ()=>{
  TARGET.A = wrapAxis(tAxis.value||0);
  tAxis.value = TARGET.A;
  recomputeOver(); updateCoach();
});

/* Generate NEW random target Rx */
randBtn.addEventListener('click', () => {
  const randS = quant05(Math.random() * (T_SPH_MAX - T_SPH_MIN) + T_SPH_MIN);
  const randC = quant05(Math.random() * (T_CYL_MIN - 0) + T_CYL_MIN); // negative to 0
  const randA = Math.floor(Math.random() * 180) + 1;
  TARGET = clampTarget({ S: randS, C: randC, A: randA });
  tSph.value = TARGET.S.toFixed(2);
  tCyl.value = TARGET.C.toFixed(2);
  tAxis.value = TARGET.A;
  recomputeOver(); updateCoach();
});

/* Plus ↔ Minus cyl toggle (Participant) */
formToggleBtn.addEventListener('click', ()=>{
  let S = parseFloat(sphInput.value)||0;
  let C = parseFloat(cylInput.value)||0;
  let A = wrapAxis(axisInput.value||0);

  // convert (S, C, A) to the other form
  const S2 = S + C;
  const C2 = -C;
  const A2 = (wrapAxis(A + 90)) || 180;

  sphInput.value  = S2.toFixed(2);
  cylInput.value  = C2.toFixed(2);
  axisInput.value = A2;

  // Button label indicates the *action* next
  formToggleBtn.textContent = (C2 < 0) ? "To +cyl" : "To −cyl";

  recomputeOver(); updateCoach();
});

/* Reset participant */
resetBtn.addEventListener('click', ()=>{
  sphInput.value  = "0.00";
  cylInput.value  = "0.00";
  axisInput.value = "180";
  formToggleBtn.textContent = "To +cyl";
  recomputeOver(); updateCoach();
});

const isPlusCylMode = () => formToggleBtn.textContent.includes("−cyl");


</script>







<script>
/* ===========================
   SMART COACH v2 (Live Hints)
=========================== */
function updateCoach(){
  // Always take live axis for reactivity
  const se   = TRUE.se;
  const cylM = Math.abs(TRUE.cyl);
  const userAxis = wrapAxis(axisInput.value || 180);

  // --- SPH Hint (keep wording)
  let sphMsg = "";
  if (se < -0.75) sphMsg = "Too blur — increase minus power.";
  else if (se > 0) sphMsg = "Add plus until red side slightly clearer.";
  else if (se <= -0.25 && se >= -0.75)
    sphMsg = "Excellent — red slightly clearer, proceed to axis adjustment.";
  else sphMsg = "Add plus, blue cannot be clearer.";

// --- AXIS Hint vs TARGET (flip 90° if +cyl view)
let targetAxis = TARGET.A || 180;
if (isPlusCylMode()) {
  targetAxis = (targetAxis + 90) % 180 || 180;
}

  let diff = Math.abs(userAxis - targetAxis);
  if (diff > 90) diff = 180 - diff;

/* --- NEW: minimal override for DUOCHROME line when cyl & axis are essentially correct --- */
if (cylM < 0.01 && diff <= 5) {
  const seNow = TRUE.se || 0;
  if (Math.abs(seNow) <= 0.05) {
    // perfectly balanced
    sphMsg = "Excellent! Looks balanced";
  } else {
    // give sharpening instruction + direction
    sphMsg = "Since CYL and AXIS is balance, fix the duochrome.";
    if (seNow > 0) {
      // blue side is clearer
      sphMsg += " Blue is clearer, add more plus.";
    } else if (seNow < 0) {
      // red side is clearer
      sphMsg += " Red is clearer, add more minus.";
    }
  }
}


  let axisMsg = "";
  if (diff > 25) axisMsg = "Still far — put AXIS to align with darker line.";
  else if (diff >= 6 && diff <= 25) axisMsg = "Almost there — fine-tune closer to darkest fan line.";
  else if (diff >= 0 && diff <= 5) axisMsg = "Excellent — proceed to check cyl power.";
  else axisMsg = "Still far — put AXIS to align with darker line.";

  // --- CYL Hint (keep wording)
  let cylMsg = "";
  if (cylM < 0.25) cylMsg = "Excellent — proceed to balance duochrome.";
  else if (cylM >= 0.25 && cylM <= 0.75)
    cylMsg = "Almost there — a little imbalanced.";
  else cylMsg = "Too uneven — recheck axis then add plus cyl until lines start balancing.";

  const box = document.getElementById("coachBox");
  if (box) {
    box.innerHTML =
      `<div><b>DUOCHROME - Sph Adjustment ▶</b> ${sphMsg}</div>` +
      `<div><b>DIRECTION - Axis Adjustment  ▶</b> ${axisMsg}</div>` +
      `<div><b>LINES DARKNESS - Cyl Adjustment ▶</b> ${cylMsg}</div>`;
  }
}

/* Reactive binding for axis (extra safety) */
["input","change","click","keydown"].forEach(evt => {
  axisInput.addEventListener(evt, updateCoach);
});

/* Initialization */
(async function init(){
  await applyLetterImages();
  sphInput.value = "0.00"; 
  cylInput.value = "0.00"; 
  axisInput.value = "180";
  TARGET = clampTarget(TARGET);
  tSph.value = TARGET.S.toFixed(2);
  tCyl.value = TARGET.C.toFixed(2);
  tAxis.value = TARGET.A;

  // Start in +cyl mode (button shows the mode you will switch TO)
  formToggleBtn.textContent = "To −cyl";

  recomputeOver();
  updateCoach();
})();

</script>






</body>
</html>

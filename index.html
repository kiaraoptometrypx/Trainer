<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Fanchart & Duochrome Trainer</title>
<style>
  body { font-family: system-ui, sans-serif; background:#fff; text-align:center; margin:20px; }
  #currentRx { font-weight:600; font-size:16px; margin-bottom:10px; }

  .card{ background:#fff; border-radius:10px; padding:20px 10px;
    box-shadow:0 0 10px rgba(0,0,0,.25); display:inline-block; border:1px solid #bbb; margin:8px 0 14px; }
  .row input[type=number]{ width:70px; text-align:center; }
  .row b{ display:inline-block; margin-bottom:6px; }
  button{ margin:5px; padding:5px 10px; cursor:pointer; }

  /* Duochrome */
  .duochrome{ display:flex; justify-content:center; align-items:center; width:300px; height:300px; margin:20px auto; position:relative; overflow:hidden; }
  .duo-side{ position:relative; width:150px; height:300px; display:flex; align-items:center; justify-content:center; overflow:clip; contain:paint; isolation:isolate; }
  @supports not (overflow: clip) { .duo-side { overflow:hidden; } }
  #redSide  { clip-path: inset(0 0 0 10px); }
  #blueSide { clip-path: inset(0 10px 0 0); }
  .duo-side img.base{ width:150px; height:300px; object-fit:cover; display:block; transition:none; will-change:filter; }
  .duo-side img.overlay{ display:none; position:absolute; left:0; top:0; width:150px; height:300px; object-fit:cover; pointer-events:none; transition:none; will-change:transform, filter, opacity; backface-visibility:hidden; transform: translate3d(0,0,0); }

  /* Fan chart */
  .outer-circle{ width:250px; height:250px; border-radius:50%; border:none; overflow:hidden; display:flex; align-items:center; justify-content:center; margin:40px auto; transform-origin:center; }
  .circular-img img{ width:300px; height:auto; object-fit:cover; object-position:center; transform-origin:center; }

  /* Layout */
  #stage { display:flex; gap:50px; align-items:center; justify-content:center; }
  .duochrome, .outer-circle { margin:12px 0; }

  .rx-input { width:120px; font-size:12px; text-align:center; padding:6px; border-radius:6px; border:1px solid #ccc; margin-bottom:5px; }
  .btn-plus, .btn-minus { font-size:14px; border:1px solid #000; padding:6px 10px; border-radius:6px; cursor:pointer; color:#fff; transition:opacity .2s; margin:2px; }
  .btn-plus { background:#212121; } .btn-minus{ background:#d9534f; }
  .btn-plus:hover, .btn-minus:hover { opacity:.85; }
  .btn-group button { font-size:12px; padding:5px 5px; margin:5px; border:1px solid #000; border-radius:10px; cursor:pointer; background:#dcdcdc; color:#000; min-width:160px; }
  .btn-group button:hover { background:#c8c8c8; }

  /* Answer row */
  #targetPanel input{ width:60px; font-size:12px; padding:5px; text-align:center; margin:2px 2px; border-radius:5px; }
</style>
</head>
<body>

<div style="height:10px;"></div>
<div id="currentRx">FANCHART & DUOCHROME TRAINER</div>
<div><span>Train over refraction here
<a href="https://kiaraoptometrypx.github.io/trainer_light/" target="_blank" rel="noopener" style="display:inline-block;padding:6px 12px;border:1px solid #000;border-radius:10px;background:#dcdcdc;text-decoration:none;color:#000;">Open Trainer</a>
</span></div>



<!-- Controls -->
<div id="controls" class="card" style="font-size:15px; width:550px">
  Your challenge is to find the RX that makes everything clear again!


<div style="height:20px"></div>


<!-- Answer -->
<div id="targetPanel" style="border:none; display:none; justify-content:center; width:550px;">

  <b>SPH</b> <input style="width:100px" type="number" id="tSph" step="0.25" value="-1.00">
  <b>CYL</b> <input style="width:100px" type="number" id="tCyl" step="0.25" value="-1.00">
  <b>AXIS</b> <input style="width:100px" type="number" id="tAxis" step="5"   value="180">
<div style="height:10px"></div>

</div>
<div style="height:10px;"></div>



  <div style="display:flex; justify-content:center; gap:50px; flex-wrap:wrap; align-items:flex-start;">

    <!-- SPH -->
    <div style="text-align:center;">
      <label><b>SPH</b></label><br>
      <input type="number" id="sph" step="0.25" value="0.00" class="rx-input"><br>
      <div>
        <button onclick="adj('sph',-0.25)" class="btn-minus">−0.25</button>
        <button onclick="adj('sph', 0.25)" class="btn-plus">+0.25</button><br>
        <button onclick="adj('sph',-1.00)" class="btn-minus">−1.00</button>
        <button onclick="adj('sph', 1.00)" class="btn-plus">+1.00</button>
      </div>
    </div>

    <!-- CYL -->
    <div style="text-align:center;">
      <label><b>CYL</b></label><br>
      <input type="number" id="cyl" step="0.25" value="0.00" class="rx-input"><br>
      <div>
        <button onclick="adj('cyl',-0.25)" class="btn-minus">−0.25</button>
        <button onclick="adj('cyl', 0.25)" class="btn-plus">+0.25</button><br>
        <button onclick="adj('cyl',-1.00)" class="btn-minus">−1.00</button>
        <button onclick="adj('cyl', 1.00)" class="btn-plus">+1.00</button>
      </div>
    </div>

    <!-- AXIS -->
    <div style="text-align:center;">
      <label><b>AXIS</b></label><br>
      <input type="number" id="axis" step="1" value="180" class="rx-input"><br>
      <div>
        <button onclick="adj('axis', -5)"  class="btn-minus">−5</button>
        <button onclick="adj('axis',  5)"  class="btn-plus">+5</button><br>
        <button onclick="adj('axis',-20)"  class="btn-minus">−20</button>
        <button onclick="adj('axis', 20)"  class="btn-plus">+20</button>
      </div>
    </div>
  </div>

  <div style="height:10px"></div>
  <div class="row btn-group">
    <button style="width:240px" id="resetBtn">Reset Rx to 0</button>
    <button style="width:240px" id="sizeBtn">Change Letter Size</button>
<div class="row btn-group">


    <button style="background:pink; border:1px solid black; width:240px;" id="formToggleBtn">Convert Cyl</button>

  <button style="background:pink; border:1px solid black; width:240px;" id="targetToggleBtn">Show Answer</button></div> 
  </div>
</div>




<div class="row btn-group" style="
  display:flex;
  flex-direction:row;   /* side by side */
  justify-content:center;
  align-items:center;
  gap:10px;             /* space between buttons */
">
  <button style="background:#fffdf0; border:1px solid grey; width:275px;" id="randBtn">New Test</button>
  <button style="background:#fffdf0; border:1px solid grey; width:275px;" id="coachStatusBtn">Show Status</button>
</div>

<!-- Smart Coach -->
<div id="coachBox" class="card" style="background:#fffdf0; display:inline-block; text-align:left; font-size:12px; width:550px; padding:20px"></div>

 



</div>

















<div style="height:10px"></div>


<!-- Stage -->
<div id="stage">
  <!-- Fan Chart (LEFT) -->
  <div id="stack" style="position:relative; width:400px; margin:0 0 20px 0;">
    <img class="bg" src="https://raw.githubusercontent.com/kiaraoptometrypx/Trainer/main/FC_DIRECTIONS.png" alt="" style="width:100%; display:block;" />
    <div class="overlay" style="position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none;">
      <div class="overlay-stage">
        <div class="outer-circle" id="outerCircle" style="width:100%; aspect-ratio:1/1; border-radius:9999px; overflow:hidden;">
          <div class="circular-img" style="width:100%; height:100%;">
            <img id="fanChart" src="https://raw.githubusercontent.com/kiaraoptometrypx/Trainer/main/C025.png" alt="" style="width:100%; height:100%; object-fit:cover;" />
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Duochrome (RIGHT) -->
  <div class="duochrome">
    <div class="duo-side" id="redSide">
      <img class="base" id="redImg"  src="https://raw.githubusercontent.com/kiaraoptometrypx/Trainer/main/RED_2.png"  alt="">
      <img class="overlay" id="redOv"  alt="">
    </div>
    <div class="duo-side" id="blueSide">
      <img class="base" id="blueImg" src="https://raw.githubusercontent.com/kiaraoptometrypx/Trainer/main/BLUE_2.png" alt="">
      <img class="overlay" id="blueOv" alt="">
    </div>
  </div>
</div>











<script>
/* =========================
   Quick adjust buttons
========================= */
function adj(type, step){
  const el = document.getElementById(type);
  let v = parseFloat(el.value)||0;
  v += step;
  if(type==='axis'){
    if(v < 1) v = 180;
    if(v > 180) v = 1;
    el.value = Math.round(v);
  } else {
    el.value = v.toFixed(2);
  }
  el.dispatchEvent(new Event('input'));
}
</script>









<script>
/* ===== Tunables & State ===== */
const PX_PER_D = 2, K_BLUR_PER_D = 2.0, EXTRA_ASTIG_BLUR_PER_D = 0.40, OVERLAY_ALPHA = 0.60, AXIS_STEP = 5;
const T_SPH_MIN = -7.00, T_SPH_MAX = +4.00, T_CYL_MIN = -4.00, T_CYL_MAX = 0.00;
const FC_BLUR_GAIN = 0.50;

const redImg = document.getElementById('redImg');
const blueImg = document.getElementById('blueImg');
const redOv  = document.getElementById('redOv');
const blueOv = document.getElementById('blueOv');
const fanImg = document.getElementById('fanChart');
const outer  = document.getElementById('outerCircle');

const sphInput = document.getElementById('sph');
const cylInput = document.getElementById('cyl');
const axisInput= document.getElementById('axis');

const randBtn = document.getElementById('randBtn');
const sizeBtn = document.getElementById('sizeBtn');
const targetToggleBtn = document.getElementById('targetToggleBtn');
const formToggleBtn = document.getElementById('formToggleBtn');
const resetBtn = document.getElementById('resetBtn');

const targetPanel = document.getElementById('targetPanel');
const tSph = document.getElementById('tSph');
const tCyl = document.getElementById('tCyl');
const tAxis= document.getElementById('tAxis');

let letterSize = 2;
let TARGET = { S: -1.00, C: -1.00, A: 180 };
let TRUE   = { sph: 0, cyl: 0, axis: 180, se: 0 };
let IS_PLUS_CYL = false;
let COACH_STAGE = 1;      // 1=DUOCHROME, 2=AXIS, 3=CYL
let STARTED = false;      // gated start

/* Preload + safe overlay src */
const SIZES = [1,2,3], cache = {};
(function preloadAll(){
  SIZES.forEach(sz=>{
    ["RED","BLUE"].forEach(col=>{
      const url = `https://raw.githubusercontent.com/kiaraoptometrypx/Trainer/main/${col}_${sz}.png`;
      const im = new Image(); im.decoding = "async"; im.src = url;
      cache[`${col}_${sz}`] = im;
    });
  });
})();
async function applyLetterImages(){
  const rKey = `RED_${letterSize}`, bKey = `BLUE_${letterSize}`;
  await Promise.all([ cache[rKey].decode?.().catch(()=>{}), cache[bKey].decode?.().catch(()=>{}) ]);
  redImg.src  = cache[rKey].src;
  blueImg.src = cache[bKey].src;
  redOv.src   = cache[rKey].src;
  blueOv.src  = cache[bKey].src;
  redOv.style.display  = 'block';
  blueOv.style.display = 'block';
}

/* Helpers */



const quant05 = v => Math.round(v*2)/2;
function wrapAxis(val){
  const n = parseFloat(val);
  if (!Number.isFinite(n)) return 0;
  const raw = String(val).trim();
  let v = ((Math.round(n) % 180) + 180) % 180;
  return raw === "180" ? 180 : (v === 0 ? 1 : v);
}
function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

/* Minus-cyl normalize + target clamp */
function normalizeMinus(S, C, A){
  if (C > 0){ S = S + C; C = -C; A = (wrapAxis(A + 90)) || 180; }
  else A = wrapAxis(A);
  return { S, C, A };
}
function clampTarget(obj){
  let S = clamp((+obj.S || 0), T_SPH_MIN, T_SPH_MAX);
  let C = (+obj.C || 0); if (C > 0) C = -C; C = clamp(C, T_CYL_MIN, T_CYL_MAX);
  let A = wrapAxis(+obj.A || 180);
  return { S, C, A };
}

/* Power-vectors */
function toVec(S, C, Adeg){
  const rad2 = (2*Adeg) * Math.PI/180;
  const M  = S + C/2;
  const J0 = -(C/2) * Math.cos(rad2);
  const J45= -(C/2) * Math.sin(rad2);
  return {M,J0,J45};
}
function fromVec(M, J0, J45){
  const C = -2 * Math.hypot(J0, J45);
  let A = 0.5 * (Math.atan2(J45, J0) * 180/Math.PI);
  A = ((A % 180) + 180) % 180 || 180;
  const S = M - C/2;
  return {S, C, A};
}

function getParticipantMinus(){
  const S = parseFloat(sphInput.value)||0;
  const C = parseFloat(cylInput.value)||0;
  const A = wrapAxis(axisInput.value||0);
  return normalizeMinus(S, C, A);
}

/* Compute Over-Rx */
function recomputeOver(){
  const Pm = getParticipantMinus();
  const Tm = normalizeMinus(...Object.values(clampTarget(TARGET)));
  const t = toVec(Tm.S, Tm.C, Tm.A);
  const p = toVec(Pm.S, Pm.C, Pm.A);
  const d = { M: t.M - p.M, J0: t.J0 - p.J0, J45: t.J45 - p.J45 };
  const o = fromVec(d.M, d.J0, d.J45);
  TRUE.sph  = o.S; TRUE.cyl  = o.C; TRUE.axis = o.A; TRUE.se = d.M;
  updateViews();
}

/* Render */
function updateViews(){
  const cyl  = TRUE.cyl, axis = TRUE.axis, deltaSE = TRUE.se;
  const s = Math.abs(deltaSE), primary = s * K_BLUR_PER_D, secondary = (s >= 0.75) ? ((s - 0.5) * K_BLUR_PER_D) : 0;
  const fcBlur = quant05(primary * FC_BLUR_GAIN);

  let blurRed=0, blurBlue=0;
  if (deltaSE > 0){ blurRed = primary; blurBlue = secondary; }
  else if (deltaSE < 0){ blurBlue = primary; blurRed = secondary; }
  redImg.style.filter  = `blur(${quant05(blurRed)}px)`;
  blueImg.style.filter = `blur(${quant05(blurBlue)}px)`;

  const mag = Math.abs(cyl) * PX_PER_D;
  let ang = (axis % 180) * 2; ang -= 90;
  const rad = ang * Math.PI / 180;
  const shiftX = Math.round(Math.cos(rad) * mag);
  const shiftY = Math.round(Math.sin(rad) * mag);
  redOv.style.transform  = `translate(${shiftX}px, ${shiftY}px)`;
  blueOv.style.transform = `translate(${shiftX}px, ${shiftY}px)`;

  const extra = Math.abs(cyl) * EXTRA_ASTIG_BLUR_PER_D;
  redOv.style.filter  = `blur(${quant05(blurRed  + extra)}px)`;
  blueOv.style.filter = `blur(${quant05(blurBlue + extra)}px)`;
  redOv.style.opacity = blueOv.style.opacity = OVERLAY_ALPHA;

  const absC = Math.abs(cyl);
  let imgName = "C025.png";
  if      (absC <= 0.25) imgName="C025.png";
  else if (absC <= 0.50) imgName="C050.png";
  else if (absC <= 0.75) imgName="C075.png";
  else if (absC <= 1.00) imgName="C100.png";
  else                   imgName="C150.png";
  fanImg.src = `https://raw.githubusercontent.com/kiaraoptometrypx/Trainer/main/${imgName}`;
  fanImg.style.filter = `blur(${fcBlur}px)`;

  const axisFC = (axis + 90) % 180;
  const fcOffset = (deltaSE > 0) ? 90 : 0;
  outer.style.transform = `scaleX(-1) rotate(${-(axisFC + fcOffset)}deg)`;

  updateCoach();
}
</script>











<script>
/* ============ Inputs & UI ============ */
[sphInput, cylInput].forEach(el => el.addEventListener('input', recomputeOver));

axisInput.addEventListener('input', () => {
  axisInput.value = wrapAxis(axisInput.value || 0);
  recomputeOver();
});

axisInput.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowUp')   { e.preventDefault(); axisInput.value = wrapAxis((parseFloat(axisInput.value)||0) + AXIS_STEP); }
  if (e.key === 'ArrowDown') { e.preventDefault(); axisInput.value = wrapAxis((parseFloat(axisInput.value)||0) - AXIS_STEP); }
  recomputeOver();
});

/* Change letter size */
sizeBtn.addEventListener('click', async () => {
  letterSize = (letterSize % 3) + 1;
  await applyLetterImages();
  updateViews();
});

/* Show / Hide Answer */
targetToggleBtn.addEventListener('click', () => {
  const open = targetPanel.style.display !== 'none';
  targetPanel.style.display = open ? 'none' : 'block';
  targetToggleBtn.textContent = open ? 'Show Answer' : 'Hide Answer';
});

/* Edit Answer (S, C, A) */
[tSph, tCyl].forEach(el => el.addEventListener('input', () => {
  TARGET.S = parseFloat(tSph.value) || 0;
  TARGET.C = parseFloat(tCyl.value) || 0;
  TARGET = clampTarget(TARGET);
  tSph.value = TARGET.S.toFixed(2);
  tCyl.value = TARGET.C.toFixed(2);
  recomputeOver();
}));

tAxis.addEventListener('input', () => {
  TARGET.A = wrapAxis(tAxis.value || 0);
  tAxis.value = TARGET.A;
  recomputeOver();
});

/* New Test */
randBtn.addEventListener('click', () => {
  STARTED = true;
  COACH_STAGE = 1;
  const randS = Math.round((Math.random() * (T_SPH_MAX - T_SPH_MIN) + T_SPH_MIN) * 4) / 4;
  const randC = Math.round((Math.random() * (0 - T_CYL_MIN) + T_CYL_MIN) * 4) / 4;
  const randA = Math.floor(Math.random() * 180) + 1;
  TARGET = clampTarget({ S: randS, C: randC, A: randA });
  tSph.value  = TARGET.S.toFixed(2);
  tCyl.value  = TARGET.C.toFixed(2);
  tAxis.value = TARGET.A;
  recomputeOver();
  updateCoach();
});

/* Convert Cyl (+↔−) */
formToggleBtn.addEventListener('click', () => {
  const S = parseFloat(sphInput.value) || 0;
  const C = parseFloat(cylInput.value) || 0;
  const A = wrapAxis(axisInput.value || 0);

  sphInput.value  = (S + C).toFixed(2);
  cylInput.value  = (-C).toFixed(2);
  axisInput.value = (wrapAxis(A + 90)) || 180;

  // track current view based on actual sign
  IS_PLUS_CYL = ((parseFloat(cylInput.value) || 0) > 0);

  recomputeOver();
  updateCoach();
});

/* Reset participant (stay at DUOCHROME) */
resetBtn.addEventListener('click', () => {
  sphInput.value  = '0.00';
  cylInput.value  = '0.00';
  axisInput.value = '180';

  IS_PLUS_CYL = false;
  COACH_STAGE = 1;
  STARTED     = true;

  recomputeOver();
  updateCoach();
});

</script>








<script>
// ======= Stages: 1..9 with custom next hops =======
function cycleCoachStage(){
  if (COACH_STAGE === 8) {
    // after re-do refine duochrome, jump back to fan check
    COACH_STAGE = 5;
  } else if (COACH_STAGE === 9) {
    // final SPH check returns to fan check loop
    COACH_STAGE = 5;
  } else {
    COACH_STAGE = COACH_STAGE + 1; // normal increment
  }
  updateCoach();
}

function isFanChartUneven(diffAxisDeg, cylShortByAbs){
  // tweak thresholds any time
  return (diffAxisDeg >= 6) || (cylShortByAbs >= 0.25);
}

function updateCoach(){
  const box = document.getElementById('coachBox');
  if (!box) return;

  if (!STARTED){
    box.innerHTML = 'Are you ready? Press <b>"New Test"</b> to start.';
    return;
  }

  const se    = TRUE.se;
  const uAxis = wrapAxis(axisInput.value || 180);

  // ===== SPH status (1/4/8) =====
  let sphMsg =
    (se < -0.75)                 ? 'Too blur — increase minus power.' :
    (se > 0)                     ? 'Blue cannot be clearer — Add plus until red side slightly clearer.' :
    (se <= -0.25 && se >= -0.75) ? 'Excellent — red slightly clearer, ready for Fan Chart balancing.' :
                                   'Blue cannot be clearer — Add plus until red side slightly clearer.';

  // ===== AXIS math (shared numbers for stages 2 & 6) =====
  const ta = wrapAxis((TARGET.A || 180) + 90);
  let diff = Math.abs(uAxis - ta); if (diff > 90) diff = 180 - diff;

  // Stage 2 copy (initial balancing)
  const axisMsg2 =
    (diff > 25) ? 'Still far — put AXIS to align with darker line.' :
    (diff >= 6) ? 'Almost there — fine-tune with small steps (5 or 1 degree) towards darker fan line.' :
                  'Excellent — proceed to check cyl power.';

  // Stage 6 copy (re-check cycle: fresh wording)
  const axisMsg6 =
    (diff > 25) ? 'Not there yet — rotate axis (in 5° steps) towards the darker fan line.' :
    (diff >= 6) ? 'Nearly there — rotate axis (in 1° steps) towards the darker fan line.' :
                  'Excellent — proceed to check cyl power.';

  // ===== CYL status (3/7) =====
  const Tm_forCyl = normalizeMinus(TARGET.S, TARGET.C, TARGET.A);
  const Pm_forCyl = getParticipantMinus();
  const targC = Math.abs(Tm_forCyl.C);
  const partC = Math.abs(Pm_forCyl.C);
  const shortBy = targC - partC;

  let cylMsg;
  if (shortBy > 0 && shortBy <= 0.50) {
    cylMsg = "Very close to even. If difficult to tell any difference, improve clarity.<br><b>Hint:</b> Improve clarity by adding minus SPH but <b>ensure red still clearer.</b>";
  } else if (shortBy < 0) {
    cylMsg = "Over-cyl — added too much cyl and opposite side darker. Reduce plus cyl.";
  } else if (shortBy > 0) {
    cylMsg = "Under-cyl — increase plus cyl until areas even. If difficult to tell any difference, improve clarity.<br><b>Hint:</b> Improve clarity by adding minus SPH but <b>ensure red still clearer.</b>";
  } else {
    cylMsg = "Excellent — proceed to refine duochrome.";
  }

  // tip tracker
  const partCylNow = parseFloat(cylInput.value) || 0;
  if (Math.abs(partCylNow - lastCylTip) >= 0.999) {
    lastCylTip = partCylNow;
  }

  // ===== Fan-chart check text (Stage 5) =====
  const fanUneven = isFanChartUneven(diff, Math.abs(shortBy));
  const fanMsgYes = "Doesn't look even — proceed to re-axis alignment.";
  const fanMsgNo  = "Looks even. Proceed to final step.";

  // ===== Render staged lines =====
  let activeLine = '';

  if (COACH_STAGE === 1) activeLine = `
    <div>
      <b>First Step — Sharpen Duochrome</b><br>
      Improve clarity but <b>keep red slightly clearer</b> on the smaller letters.
      <br><br>Press 'Show Status' to check your answer.
      <br><br><div class="hint">Status: ${sphMsg}</div>
    </div>`;

  if (COACH_STAGE === 2) activeLine = `
    <div>
      <b>Second Step — Fan Chart Balancing</b><br>
      Identify <b>the center axis of the darker area</b>.
      <br><br>Press 'Show Status' to check your answer.
      <br><br><div class="hint">Status: ${axisMsg2}</div>
    </div>`;

  if (COACH_STAGE === 3) activeLine = `
    <div>
      <b>Third Step — Add Plus Cyl</b><br>
      <b>Plus cyl softens darker area</b>; everything must look even.
      <br><br>Press 'Show Status' to check your answer.
      <br><br><div class="hint">Status: ${cylMsg}</div>
    </div>`;

  if (COACH_STAGE === 4) activeLine = `
    <div>
      <b>Fourth Step — Refine Duochrome</b><br>
      Improve clarity <b>again</b> but <b>keep red slightly clearer</b> on the smaller letters.
      <br><br>Press 'Show Status' to check your answer.
      <br><br><div class="hint">Status: ${sphMsg}</div>
    </div>`;

  if (COACH_STAGE === 5) activeLine = `
    <div>
      <b>Fifth Step — Fan Chart Balancing Again: Is Fan Chart even?</b><br>
      If no, repeat Fan Chart Balancing test. If yes, proceed to Sharpening test.
      <div id="fanActions"
           style="margin-top:12px; display:flex; gap:8px; justify-content:center;">
        <button id="coachNoBtn"  style="font-size:10px; padding:4px 8px; cursor:pointer;">No</button>
        <button id="coachYesBtn" style="font-size:10px; padding:4px 8px; cursor:pointer;">Yes</button>
      </div>
      <div id="fanHint" class="hint" style="margin-top:10px;">
        Status: ${fanUneven ? fanMsgYes : fanMsgNo}
      </div>
    </div>`;

  if (COACH_STAGE === 6) activeLine = `
    <div>
      <b>Re-do Fan Chart Balancing</b><br>
      Re-align to <b>the center axis of darker area in small steps (5° or 1°)</b>.
      <br><br>Press 'Show Status' to check your answer.
      <br><br><div class="hint">Status: ${axisMsg6}</div>
    </div>`;

  if (COACH_STAGE === 7) activeLine = `
    <div>
      <b>Re-do Add Plus Cyl</b><br>
      Increase <b>plus cyl in small steps</b> until chart looks even.
      <br><br>Press 'Show Status' to check your answer.
      <br><br><div class="hint">Status: ${cylMsg}</div>
    </div>`;

  if (COACH_STAGE === 8) activeLine = `
    <div>
      <b>Re-do Refine Duochrome</b><br>
      Improve clarity <b>again</b> but <b>keep red slightly clearer</b> on the smaller letters.
      <br><br>Press 'Show Status' to check your answer.
      <br><br><div class="hint">Status: ${sphMsg}</div>
    </div>`;

  // ===== Stage 9 — SE=0 (no red/blue bias) =====
  const SE_TOL = 0.12; // accept ±0.12 D as "Excellent"
  let sph9Msg;

  if (Math.abs(se) <= SE_TOL) {
    sph9Msg = "Excellent — Red & Blue equally clear. <br><b>Convert Cyl then Check your answer above!</b>";
  } else if (se > SE_TOL) {
    // Too plus-biased → blue/green tends to look clearer
    sph9Msg = "Blue side is clearer — add a little <b>minus</b></span> until balance.";
  } else { // se < -SE_TOL
    // Too minus-biased → red tends to look clearer
    sph9Msg = "Red side is clearer — add a little <b>plus</b></span> until balance.";
  }

  if (COACH_STAGE === 9) activeLine = `
    <div>
      <b>Final Step — Sharpen vision on Small Letters</b><br>
      Add minus SPH until <b>small letters in both red and blue are equally clear.</b> If over shoot, reduce the SPH.
      <br><br>Press 'Show Status' to check your answer.
      <br><br><div class="hint">Status: ${sph9Msg}</div>
    </div>`;

  // ---- render
  box.innerHTML = activeLine;

  // ===== Stage 5 buttons (Yes/No) =====
  if (COACH_STAGE === 5){
    const yesBtn  = document.getElementById('coachYesBtn');
    const noBtn   = document.getElementById('coachNoBtn');

    // YES = Fan chart even → go directly to Stage 9
    if (yesBtn) yesBtn.onclick = () => {
      STATUS_REVEALED = false;
      applyStatusVeil();
      const statusBtn = document.getElementById('coachStatusBtn');
      if (statusBtn) statusBtn.textContent = 'Show Status';
      COACH_STAGE = 9;
      updateCoach();
    };

    // NO = Uneven → Stage 6 (re-axis) → 7 → 8 → back to 5
    if (noBtn) noBtn.onclick = () => {
      STATUS_REVEALED = false;
      applyStatusVeil();
      const statusBtn = document.getElementById('coachStatusBtn');
      if (statusBtn) statusBtn.textContent = 'Show Status';
      COACH_STAGE = 6;
      updateCoach();
    };
  }

  // ===== “Next” button for all stages EXCEPT stage 5 =====
if (COACH_STAGE !== 5 && COACH_STAGE !== 9){
    const btn = document.createElement('button');
    btn.id = 'coachNextBtn';
    btn.textContent = 'Next ▶';
    btn.style.marginTop = '5px';
    btn.style.fontSize = '10px';
    btn.style.cursor = 'pointer';
    btn.onclick = () => {
      STATUS_REVEALED = false;
      applyStatusVeil();
      const statusBtn = document.getElementById('coachStatusBtn');
      if (statusBtn) statusBtn.textContent = 'Show Status';
      cycleCoachStage();
    };
    box.appendChild(btn);

    // show Next only when the HINT says “Excellent”
    const hint = box.querySelector('.hint');
    const hasExcellent = hint ? hint.textContent.includes('Excellent') : false;
    btn.style.display = hasExcellent ? 'inline-block' : 'none';
  }

  applyStatusVeil(); // keep veil state
}
</script>










<script>
/* ============ Init ============ */
(async function init(){
  await applyLetterImages();
  sphInput.value  = '0.00';
  cylInput.value  = '0.00';
  axisInput.value = '180';

  TARGET = clampTarget(TARGET);
  tSph.value  = TARGET.S.toFixed(2);
  tCyl.value  = TARGET.C.toFixed(2);
  tAxis.value = TARGET.A;

  IS_PLUS_CYL = false;
  COACH_STAGE = 1;
  STARTED     = false;

  lastCylTip  = parseFloat(cylInput.value) || 0; // init CYL tip tracker

  document.getElementById('coachBox').innerHTML = 'Are you ready? Press <b>"New Test"</b> to start.';
  recomputeOver();
})();
</script>





<style>
/* fixed, large coach box */
#coachBox{
  min-height:140px;
max-width:530px;
  overflow:hidden; /* prevents expansion */
  display:flex; align-items:center; justify-content:center;
  text-align:center;
}

/* veil (no HTML changes required) */
.hint{ position:relative; }
.hint::after{
  content:"";
  min-height:110px;

  position:absolute; inset:0;
  background:#fffdf0;   /* veil color */
  opacity:1;       /* veil strength */
  pointer-events:auto; /* block interaction */
}
.hint.revealed::after{
  opacity:0;
  pointer-events:none;
}
</style>




<script>
// external toggle state
let STATUS_REVEALED = false;

// toggle button outside the coach box (ID you control)
const statusBtn = document.getElementById('coachStatusBtn');
if (statusBtn){
  const setLabel = () => statusBtn.textContent = STATUS_REVEALED ? 'Hide Status' : 'Show Status';
  statusBtn.addEventListener('click', () => {
    STATUS_REVEALED = !STATUS_REVEALED;
    applyStatusVeil();
    setLabel();
  });
  setLabel();
}

// apply veil class to current hints
function applyStatusVeil(){
  const hints = document.querySelectorAll('#coachBox .hint');
  hints.forEach(h => h.classList.toggle('revealed', STATUS_REVEALED));
}
</script>












<div style="height:300px"></div>
</body>
</html>
